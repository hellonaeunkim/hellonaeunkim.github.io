---
layout: single
title: "Two Sum"
categories: LeetCode
---

* **Problem LeetCode Link** : <a href="https://leetcode.com/problems/two-sum/" target="_blank">Two Sum</a>
* **Solution Reference** : <a href="https://www.youtube.com/watch?v=KLlXCFG5TnA" target="_blank">Solution</a>
* **Language** : Python 3
* **Time complexity** : 0(n)
* **Explainning on my own words**
  - **Problem**
    ```python3
    class Solution:
      def twoSum(self, nums: List[int], target: int) -> List[int]:
    ```
  - **Solution**
    ```python3
    class Solution:
      def twoSum(self, nums: List[int], target: int) -> List[int]:
        prevMap = {} # val : index

        for i, n in enumerate(nums):
          diff = target - n
          if diff in prevMap:
            return [prevMap[diff], i]
          prevMap[n] = i
      return
    ```
  - **Explain** <br>
  * Introduction
So, we are provided with an input array and a target value, which in this case is 9. Our goal is to find two values within this input array that sum up to 9. For this instance, those values are 2 and 7. Our objective is to return the indices of these two values, which are 0 and 1 respectively.

The most straightforward approach to solving this problem is to examine every possible combination of two values and determine if their sum equals the target. This involves iterating through each element and pairing it with every other subsequent element in the array. For example, starting with 2, we check its compatibility with the remaining values (7, 11, and 15). Since none of these combinations results in the desired target sum, we proceed to the next number in the array.

This process is repeated for each element in the array. When examining the combinations for 11, we don't need to recheck combinations we've already assessed; for example, the combination of 7 and 11 was evaluated earlier when the examining the combinations for 7.

However, this algorithm's runtime efficiency is relatively low, as it employs a brute force approach. It iterates through the entire array of length 'n' for each element, which results in a worst-case time complexity of O of N squared (O(n^2)).
 
  * Main body
In this case, the value we're looking for is the difference between the target and this value, 2. For example, here's number 2 and we're looking for 9 minus 2 which is equal to 7, so that means this is the only value we can add to number 2 that'll equal the target. So, we don't have to check every number and we just want to know if 7 exists. Now, the easiest way we can do this the most efficient is by making a hash map of every value in out input array. So, we can istantly check if the value 7 exists.

    ✔️Hash Map : 
