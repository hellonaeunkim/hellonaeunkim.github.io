---
layout: single
title: "Two Sum"
categories: LeetCode
---

* **Problem LeetCode Link** : <a href="https://leetcode.com/problems/two-sum/" target="_blank">Two Sum</a>
* **Solution Reference** : <a href="https://www.youtube.com/watch?v=KLlXCFG5TnA" target="_blank">Solution</a>
* **Language** : Python 3
* **Time complexity** : 0(n)
* **Explainning on my own words**
  - **Problem**
    ```python3
    class Solution:
      def twoSum(self, nums: List[int], target: int) -> List[int]:
    ```
  - **Solution**
    ```python3
    class Solution:
      def twoSum(self, nums: List[int], target: int) -> List[int]:
        prevMap = {} # val : index

        for i, n in enumerate(nums):
          diff = target - n
          if diff in prevMap:
            return [prevMap[diff], i]
          prevMap[n] = i
      return
    ```
  - **Explain** <br>
    * Introduction <br>
&nbsp; So, we are provided with an input array and a target value, which in this case is 9. Our goal is to find two values within this input array that sum up to 9. For this instance, those values are 2 and 7. Our objective is to return the indices of these two values, which are 0 and 1 respectively.<br>
&nbsp; The most straightforward approach to solving this problem is to examine every possible combination of two values and determine if their sum equals the target. This involves iterating through each element and pairing it with every other subsequent element in the array. For example, starting with 2, we check its compatibility with the remaining values (7, 11, and 15). Since none of these combinations results in the desired target sum, we proceed to the next number in the array.<br>
&nbsp; This process is repeated for each element in the array. When examining the combinations for 11, we don't need to recheck combinations we've already assessed; for example, the combination of 7 and 11 was evaluated earlier when the examining the combinations for 7.<br>
&nbsp; However, this algorithm's runtime efficiency is relatively low, as it employs a brute force approach. It iterates through the entire array of length 'n' for each element, which results in a worst-case time complexity of O of N squared (O(n^2)).

    * Main Body <br>
&nbsp; In this case, the value we're looking for is the difference between the target and this values. For example, here's number 2 and we're looking for 9 minus 2 which is equal to 7, so that means this is the only value we can add to number 2 that'll equal the target. So, we don't have to check every number and we just want to know if 7 exists. Now, the easiest way we can do this the most efficient is by making a hash map of every value in our input array. So, we can istantly check if the value 7 exists.<br>
&nbsp; Now, let's approach this same problem using a hash map. In this hash map, we'll map each value to its corresponding index. For example, the index of 2 is 0, the index of 7 is 1, the index of 11 is 2, and the index of 15 is 3. This means that in our hash map, we're associating each value with its index.<br>
&nbsp; If we added the entire array into the hash map initially, we would encounter the value 2 first. We need to check if the difference between the target (9) and this value (2) exists in our hash map.<br>
&nbsp; But, in this situation, if the target number is 4, we need to find the number 2 in the hash map and we can find number 2 at the same index. Since we can't reuse the same element twice, we need to compare the index of our current 2 with the index of the 2 that's already in the hash map.<br>
&nbsp; So, instead of adding every value in the array to the hash map, there's another approach. Using this method, we start with an empty hash map. For example, when we encounter the value 2, we check if the difference 9 minus 2 exists in the hash map. Since our hash map is empty, we don't find 2 initially. After this, we add number 2 to the hash map with an index of 0.<br>
&nbsp; By iterating this way, we're assured that once we encounter the second value that sums up to the target, the first one is already in our hash map. This allows us to find the solution in just one pass through the array. The algorithm's time complexity is O(n) due to the one-pass nature, and the memory complexity is O(n) because of the potential to add every value to the hash map.<br>

    * Conclusion <br>
&nbsp; pass <br>

    * Check Point <br>
      ✔️Hash Map : <br>
      ✔️enumerate() : <br>


<!--  &nbsp;      <br> : space and new line  -->
