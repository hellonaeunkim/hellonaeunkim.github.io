---
layout: single
title: "Two Sum"
categories: LeetCode
---

* **Problem LeetCode Link** : <a href="https://leetcode.com/problems/two-sum/" target="_blank">Two Sum</a>
* **Solution Reference** : <a href="https://www.youtube.com/watch?v=KLlXCFG5TnA" target="_blank">Solution</a>
* **Language** : Python 3
* **Time complexity** : 0(n)
* **Explainning on my own words**
  - **Problem**
    ```python3
    class Solution:
      def twoSum(self, nums: List[int], target: int) -> List[int]:
    ```
  - **Solution**
    ```python3
    class Solution:
      def twoSum(self, nums: List[int], target: int) -> List[int]:
        prevMap = {} # val : index

        for i, n in enumerate(nums):
          diff = target - n
          if diff in prevMap:
            return [prevMap[diff], i]
          prevMap[n] = i
    ```
  - **Explain** <br>
    * Introduction <br>
&nbsp; So, we are provided with an input array and a target value, which in this case is 9. Our goal is to find two values within this input array that sum up to 9. For this instance, those values are 2 and 7. Our objective is to return the indices of these two values, which are 0 and 1 respectively.<br>
&nbsp; The most straightforward approach to solving this problem is to examine every possible combination of two values and determine if their sum equals the target. This involves iterating through each element and pairing it with every other subsequent element in the array. For example, starting with 2, we check its compatibility with the remaining values (7, 11, and 15). Since none of these combinations results in the desired target sum, we proceed to the next number in the array.<br>
&nbsp; This process is repeated for each element in the array. When examining the combinations for 11, we don't need to recheck combinations we've already assessed; for example, the combination of 7 and 11 was evaluated earlier when the examining the combinations for 7.<br>
&nbsp; However, this algorithm's runtime efficiency is relatively low because it uses a brute force approach. It iterates through the entire array of length 'n' for each element, which results in a worst-case time complexity of O of N squared (O(n^2)).

    * Main Body <br>
&nbsp; In this case, the value we're looking for is the difference between the target and this values. For example, here's number 2 and we're looking for 9 minus 2 which is equal to 7, so that means this is the only value we can add to number 2 that'll equal the target. So, we don't have to check every number and we just want to know if 7 exists. Now, the easiest way we can do this the most efficient is by making a hash map of every value in our input array. So, we can istantly check if the value 7 exists.<br>
&nbsp; Now, let's approach this same problem using a hash map. In this hash map, we'll map each value to its corresponding index. For example, the index of 2 is 0, the index of 7 is 1, the index of 11 is 2, and the index of 15 is 3. This means that in our hash map, we're associating each value with its index.<br>
&nbsp; If we added the entire array into the hash map initially, we would encounter the value 2 first. We need to check if the difference between the target (9) and this value (2) exists in our hash map.<br>
&nbsp; But, in this situation, if the target number is 4, we need to find the number 2 in the hash map and we can find number 2 at the same index. Since we can't reuse the same element twice, we need to compare the index of our current 2 with the index of the 2 that's already in the hash map.<br>
&nbsp; So, instead of adding every value in the array to the hash map, there's another approach. Using this method, we start with an empty hash map. For example, when we encounter the value 2, we check if the difference 9 minus 2 exists in the hash map. Since our hash map is empty, we don't find 2 initially. After this, we add number 2 to the hash map with an index of 0.<br>
&nbsp; By iterating this way, we're assured that once we encounter the second value that sums up to the target, the first one is already in our hash map. This allows us to find the solution in just one pass through the array. The algorithm's time complexity is O(n) because it operates in a single pass, and the memory complexity is O(n) because of the potential to add every value to the hash map.<br>

    * Conclusion <br>
&nbsp; So, I'm going to code the solution, starting with an empty hash map. I'm going to name it 'previous map' because this hash map will contain information about all the elements that appear earlier in the array before reaching the current element. Every previous element will be stored in this map, allowing us to map the value to its corresponding index.<br>
&nbsp; Now, I'm going to iterate through every value in this array. We need both the index and the actual number. And I'm going to use 'enumerate' function which returns a tuple containing the index and the item from the list. <br>
&nbsp; Before we add this value to the map, let's check for the difference, which is the target minus the value 'n'. <br>
&nbsp; Now, we'll verify if this difference already exists in the hash map. If this difference in this hash map, we can return the solution, which is going to be a pair of indices. The first index is like this (prevMap[diff]), and the second index is just 'i'. <br>
&nbsp; However, if we fail to find a solution, we need to update our hash map. For this value 'n', I'll assign the index 'i', and then we'll continue. <br>
&nbsp; So, this is my solution of this problem. Thanks. <br>

    * Check Point <br>
      ✔️Hash Map : n Python, a "hash map" is often referred to as a "dictionary." A dictionary is a built-in data structure that allows you to store and retrieve data in a key-value pair format. -ChatGPT <br>
      ✔️enumerate() : In Python is a built-in function that is used to iterate over an iterable (e.g., a list, tuple, or string) while keeping track of the index (position) of the current item. It returns a tuple containing the index and the item from the iterable. -ChatGPT <br>
      ✔️The variable names are important? : <br>


<!--  &nbsp; and <br> : space and new line  -->
